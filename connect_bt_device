#!/usr/bin/env ruby

require 'simple_scripting/argv'
require 'simple_scripting/configuration'

require 'open3'
require 'io/wait'
require 'shellwords'

class ApplicationConfiguration
  def load_arguments_and_configuration
    devices_configuration = load_devices_configuration

    long_help = <<~HELP
      Connect an audio BT device (referred as "slave") to the system (referred as "master").

      Besides providing a mean to perform the operation, the script helps the user working around the extremely annoying issues with the steaming pile of trash that are Bluetooth, Bluez, and the Ubuntu BT support.

      The combination of the above is very unreliable, and repeated attempts are often necessary to connect devices.
      In addition, Ubuntu has shipped a broken stack in any version, including any LTS. A specific workaround is provided for working around a bug in Ubuntu 16.04.

      The script will preserve the Bluetooth master devices status, so if BT is disabled, the script will enable it, and disable it on exit.

      Switches:

      <device>: Prefix of the slave device name to connect.

      Configured slave devices: #{devices_configuration.keys.map { |name| name + (name == devices_configuration.keys.first ? " (default)" : "") }.join(', ')}

      Configuration:

      The configuration file ("$HOME/.connect_bt_device") is a typical configfile with each line being `<device_name> = <device_id>`.
      The first line is the default device.
    HELP

    options = SimpleScripting::Argv.decode(
      [ '-a', '--reset-a2dp-profile',   'Reset the A2DP profile (Ubuntu 16.04 workaround)' ],
      '[device]',
      long_help: long_help
    ) || exit

    slave_device_id = find_slave_device_id(devices_configuration, options[:device])

    [slave_device_id, !!options[:reset_a2dp_profile]]
  end

  private

  def load_devices_configuration
    devices_configuration = SimpleScripting::Configuration.load.to_h.map { |name, id| [name.to_s, id] }.to_h

    if devices_configuration.empty?
      raise "No devices configured!"
    else
      devices_configuration
    end
  end

  def find_slave_device_id(devices_configuration, device_prefix)
    if device_prefix
      # simplified algorithm
      matching_devices = devices_configuration.select { |name, _| name.start_with?(device_prefix) }

      case matching_devices.size
      when 0
        raise "No matching devices found!"
      when 1
        matching_devices.values.first
      when 2
        raise "Multiple devices found: #{matching_devices.map(&:first)}"
      end
    else
      devices_configuration.values.first
    end
  end
end # ApplicationConfiguration

module BluetoothDevicesConnectionHelper
  def connect_audio_slave_device(slave_device_id, pa_card_name, reset_a2dp_profile: false)
    with_bluetooth_ctl do |stdin, stdout|
      connect_slave_device_loop(slave_device_id, stdin, stdout)

      if reset_a2dp_profile
        set_pa_card_profile(pa_card_name, 'off')

        disconnect_slave_device_loop(slave_device_id, stdin, stdout)
        connect_slave_device_loop(slave_device_id, stdin, stdout)

        set_pa_card_profile(pa_card_name, 'a2dp_sink')
      end
    end
  end

  def disconnect_slave_device(slave_device_id)
    with_bluetooth_ctl do |stdin, stdout|
      disconnect_slave_device_loop(slave_device_id, stdin, stdout) if slave_device_connected?(slave_device_id, stdin, stdout)
    end
  end

  private

  # :readline will block if there is no input available, while :readX will raise an error; in order
  # to solve this problem easily, the 'io/wait' library makes `IO#ready?` available.
  #
  # params:
  #   wait_pattern: keep reading until the expected pattern is found
  #   timeout: in seconds; used only when :wait_pattern is specified
  #
  #
  def read_available_io(io, wait_pattern: nil, timeout: 1)
    buffer = ''
    start_time = Time.now.to_f

    while true
      buffer << io.readchar while io.ready?

      if wait_pattern
        if buffer =~ wait_pattern
          break
        elsif timeout && Time.now.to_f >= start_time + timeout
          raise "Timout while waiting for pattern #{wait_pattern} not found; current buffer: #{buffer}"
        else
          sleep 0.1
        end
      else
        break
      end
    end

    buffer
  end

  def with_bluetooth_ctl(&block)
    Open3.popen3('bluetoothctl') do |stdin, stdout, _, _|
      puts read_available_io(stdout, wait_pattern: /^Agent registered/)

      yield(stdin, stdout)
    end
  end

  def connect_slave_device_loop(slave_device_id, bt_ctl_in, bt_ctl_out)
    loop do
      bt_ctl_in.puts("connect #{slave_device_id}")

      while true
        output = read_available_io(bt_ctl_out)

        puts output if output != ''

        case output
        when /Connection successful/
          puts
          return
        when /Failed to connect/
          break
        else
          sleep 0.5
        end
      end
    end
  end # connect_slave_device_loop

  def set_pa_card_profile(card, profile)
    puts "Setting PA card profile: #{profile}"

    Open3.popen3("pactl set-card-profile #{card} #{profile}") do |_, _, stderr, wait_thread|
      if ! wait_thread.value.success?
        puts stderr.readlines.join
        exit
      end
    end

    puts
  end

  def slave_device_connected?(slave_device_id, bt_ctl_in, bt_ctl_out)
    bt_ctl_in.puts("info #{slave_device_id}")

    device_information = read_available_io(bt_ctl_out, wait_pattern: /^\s+Connected: \w+$/)

    device_information =~ /^\s+Connected: yes$/
  end

  def disconnect_slave_device_loop(slave_device_id, bt_ctl_in, bt_ctl_out)
    loop do
      bt_ctl_in.puts("disconnect #{slave_device_id}")

      while true
        output = read_available_io(bt_ctl_out)

        puts output if output != ''

        # Disconnection will always be successful, when the device is available.
        #
        case output
        when /Successful disconnected/
          puts
          return
        when /(Device [0-9A-F:] not available)/
          raise $1
        else
          sleep 0.5
        end
      end
    end
  end # :disconnect_slave_device_loop
end # BluetoothDevicesConnectionHelper

# In this context, `device` refers to the master device(s).
#
class BluetoothStateManager
  DEVICE_BLOCKED = 'blocked'

  include BluetoothDevicesConnectionHelper

  def with_bluetooth_enabled
    device_start_statuses = find_device_statuses

    check_device_statuses!(device_start_statuses)

    enable_all_devices if devices_blocked?(device_start_statuses)

    slave_device_id = yield

    if devices_blocked?(device_start_statuses)
      pause

      disconnect_slave_device(slave_device_id)

      disable_all_devices
    end
  end

  private

  # Returns:
  #
  #   { "device_id" => ("blocked"|"unblocked")}
  #
  def find_device_statuses
    statuses = `rfkill`.scan(/^ *\d+ bluetooth (\w+) +(\w+)/)

    if statuses.empty?
      raise "No master devices found!"
    else
      statuses.to_h
    end
  end

  # Allow only all blocked or all unblocked.
  #
  def check_device_statuses!(statuses)
    raise "Mixed statuses found: #{statuses}" if statuses.values.uniq.size != 1
  end

  def devices_blocked?(statuses)
    statuses.values.uniq == [DEVICE_BLOCKED]
  end

  def enable_all_devices
    puts "Enabling BT...", ""

    `rfkill unblock bluetooth`
  end

  def pause
    print 'Press Enter to disable BT and exit...'
    gets
  end

  def disable_all_devices
    puts "Disabling BT...", ""

    `rfkill block bluetooth`
  end
end # BluetoothStateManager

class BluetoothDevicesConnectionManager
  include BluetoothDevicesConnectionHelper

  # Returns the device id (mostly, for convenience).
  #
  def connect(slave_device_id, reset_a2dp_profile: false)
    bluez_pa_card_name = generate_bluez_pa_card_name(slave_device_id)

    connect_audio_slave_device(slave_device_id, bluez_pa_card_name, reset_a2dp_profile: reset_a2dp_profile)

    slave_device_id
  end

  private

  # Example:
  #
  #   00:1B:66:7F:E6:F3 -> bluez_card.00_1B_66_7F_E6_F3
  #
  # Names can be manually found via `pactl list cards`.
  #
  def generate_bluez_pa_card_name(slave_device_id)
    "bluez_card." + slave_device_id.gsub(':', '_')
  end
end

if __FILE__ == $PROGRAM_NAME
  slave_device_id, reset_a2dp_profile = ApplicationConfiguration.new.load_arguments_and_configuration

  BluetoothStateManager.new.with_bluetooth_enabled do
    BluetoothDevicesConnectionManager.new.connect(slave_device_id, reset_a2dp_profile: reset_a2dp_profile)
  end
end
