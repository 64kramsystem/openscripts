#!/usr/bin/env bash

set -o errexit

c_help="Usage: $(basename "$0") [-n|--no-poweroff] [<block_device>|<mtp_uri>]

Unmounts and powers off a disk, or unmounts MTP devices (phones), like the typical desktop environment functionality.
The prefix \`/dev/\` is automatically added to block devices, if not present.

If no arguments are passed, all the USB storage devices are ejected and all MTP devices are unmounted.

If the \`no-poweroff\` option is passed, the partitions are unmounted, but the disk is not powered off (applies to block devices only)."
v_option_device=
v_option_no_poweroff=

declare -a v_devices
declare -a v_mtp_devices

function decode_commandline_arguments {
  eval set -- "$(getopt --options hn --long help,no-poweroff -- "$@")"

  while true; do
    case $1 in
      -h|--help)
        echo "$c_help"
        exit 0
        ;;
      -n|--no-poweroff)
        v_option_no_poweroff=1
        shift
        ;;
      --)
        shift
        break
        ;;
    esac
  done

  if [[ $# -gt 1 ]]; then
    echo "$c_help"
    exit 1;
  elif [[ $# == 0 ]]; then
    v_option_device=
  else
    v_option_device="$1"
  fi
}

function set_devices {
  if [[ "$v_option_device" == "" ]]; then
    find_usb_storage_devices
    find_mtp_devices
  elif [[ $v_option_device =~ ^mtp:// ]]; then
    v_mtp_devices+=("$v_option_device")
  elif [[ $v_option_device =~ ^/dev/ ]]; then
    v_devices+=("$v_option_device")
  else
    v_devices+=("/dev/$v_option_device")
  fi
}

function find_usb_storage_devices {
  for device in /sys/block/*; do
    local usb_storages_info device_name

    usb_storages_info=$(udevadm info --query=property --path="$device")

    # Devices like the Kingston DataTraveler Max have an ATA bus.
    #
    if echo "$usb_storages_info" | grep -qP '^ID_BUS=(usb|ata)'; then
      device_name=$(echo "$usb_storages_info" | perl -ne 'print $1 if /^DEVNAME=(.*)/')
      v_devices+=("$device_name")
    fi
  done
}

function find_mtp_devices {
  # Find all MTP devices using gio mount -l
  # Sample output:
  #   Mount(0): Phone Model -> mtp://Manufacturer_Model_XXXXXXXXXXXX/
  #
  local mtp_list mtp_uri
  # Deduplicate: gio mount -l shows the same MTP URI multiple times (once as a named mount, once
  # as a generic "mtp" mount), but we only want to unmount each device once.
  #
  declare -A unique_uris
  mtp_list=$(gio mount -l 2>/dev/null || true)

  while IFS= read -r line; do
    if [[ $line =~ -\>\ (mtp://[^[:space:]]+) ]]; then
      unique_uris["${BASH_REMATCH[1]}"]=1
    fi
  done <<< "$mtp_list"

  for mtp_uri in "${!unique_uris[@]}"; do
    v_mtp_devices+=("$mtp_uri")
  done
}

function unmount_mtp_device() {
  local mtp_uri="$1"

  if gio mount -u "$mtp_uri" 2>/dev/null; then
    echo "MTP device $mtp_uri unmounted."
  else
    echo "Failed to unmount MTP device $mtp_uri or already unmounted."
  fi
}

function unmount_device_partitions() {
  # LUKS encrypted partitions need a different treatment.
  #
  local device_tree

  # Sample output (unprocessed):
  #
  #   NAME                                          TYPE  MOUNTPOINT
  #   sde                                           disk
  #   └─sde1                                        part
  #     └─luks-00000000-0000-0000-0000-000000000000 crypt /path/to/mountpoint
  #
  device_tree=$(lsblk -n -o NAME,TYPE,MOUNTPOINT "$device" || true)

  # Umount the encrypted partition(s).
  # The second `\S+` ensures that there is a mountpoint.
  #
  for luks_device in $(echo "$device_tree" | perl -lne 'print $1 if /([\w-]+) crypt \S+$/'); do
    udisksctl unmount -b "/dev/mapper/$luks_device"
  done

  # Lock the LUKS device.
  #
  for luks_device in $(echo "$device_tree" | perl -lne 'print $1 if /(\w+) +part/'); do
    # It's not clear how to check, without sudo permissions, if a LUKS device is locked, so this is
    # based on empirical tests: on unlocked, the entry below has a full path, while on locked ones,
    # it has only the slash.

    if udisksctl info -b "/dev/$luks_device" | grep -qP "CleartextDevice: +'/\S+'"; then
      udisksctl lock -b "/dev/$luks_device"
    fi
  done

  # Cheap way of finding the mounted partitions of a given device.
  #
  for partition in $(mount | grep "^$device" | awk '{print $1}'); do
    udisksctl unmount -b "$partition"
  done
}

function power_off_device() {
  if [[ -e "$device" ]]; then
    udisksctl power-off -b "$device"
    echo "Device $device powered off."
  else
    # Simplified message, based on reasonable assumption (see comment below).
    echo "Device $device already powered off."
  fi
}

decode_commandline_arguments "$@"

set_devices

# Some peripherals may expose multiple devices (eg. card readers). In this case, when
# we power off the first device, the other ones will be implicitly powered off too.
# This is possibly ok (unmounting may be implicitly performed), however, for cleanness,
# first we umount all, then we (conditionally) power off.
#
for device in "${v_devices[@]}"; do
  unmount_device_partitions
done

if [[ "$v_option_no_poweroff" != "1" ]]; then
  for device in "${v_devices[@]}"; do
    power_off_device
  done
fi

# Unmount MTP devices (phones, tablets, etc.)
#
for mtp_uri in "${v_mtp_devices[@]}"; do
  unmount_mtp_device "$mtp_uri"
done
