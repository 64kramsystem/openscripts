#!/bin/bash

set -o errexit

c_configuration_file="$HOME/.$(basename "$0")"
c_development_branch_config_key=custom.development-branch
c_help="\
Usage: $(basename "$0")

Delete all the branches (local, and their remote tracked) that haven't any commits that aren't in the dev branch.
Can be run from any branch, but requires a clean tree.

Before performing the purge, the repository is synced, and the dev branch is rebased.

A branch is never deleted if it's the dev branch, or if it's included in the configfile ($c_configuration_file)
The development branch is either configured via '$c_development_branch_config_key' git config key, or via origin/HEAD.

The configfile format is composed of multiple lines in the format '<repo_dirname>:<branches_regexp>'.
Empty lines are ignored.

Example configfile:

  qemu-pinning:^.*-pinning$
  myrepo:^(branch1|branch2)$
"

v_dev_branch=
declare -A v_protected_branches
v_start_branch=

function decode_cmdline_params {
  if [[ $# -gt 0 ]]; then
    echo "$c_help"
    exit 0
  fi
}

function check_working_tree {
  if ! git status | grep -q "nothing to commit, working tree clean"; then
    echo 'Please commit/stash any change before proceeding!'
    exit 1
  fi
}

function store_branch_names {
  v_dev_branch=$(git config "$c_development_branch_config_key" || git rev-parse --abbrev-ref origin/HEAD | awk -F/ '{print $NF}')
  v_start_branch=$(git rev-parse --abbrev-ref HEAD)
}

function set_protected_branches {
  # Make sure the file exists.
  #
  touch "$c_configuration_file"

  while IFS='= ' read -r key value || [ -n "$key" ]; do
    if [[ $key != "" ]]; then
      v_protected_branches[$key]="$value"
    fi
  done < "$c_configuration_file"
}

function sync_repositories {
  git fetch --all --tags --prune
  echo
}

function switch_to_dev_branch {
  if [[ $v_start_branch != "$v_dev_branch" ]]; then
    # Keep the message consistent with the one when checkout back to this branch (see return_to_starting_branch()).
    git checkout "$v_dev_branch" 2>&1 | head -n 1
    echo
  fi
}

function rebase_dev_branch {
  git rebase
  echo
}

function delete_empty_branches {
  local repo_dirname protected_branches_pattern

  repo_dirname=$(basename "$(readlink -f .)")
  # If no protected branches are specified, use a phony pattern (will match empty branch names, which are not possible).
  protected_branches_pattern=${v_protected_branches[$repo_dirname]:-^$}

  for branch in $(git branch | cut -c 3- | grep -v "^$v_dev_branch\$" | grep -vP "$protected_branches_pattern" ); do
    if ! git cherry "$v_dev_branch" "$branch" | grep -q '^+'; then
      git branch -D "$branch"
      echo

      if git branch -r | grep "origin/$branch\$"; then
        git push origin :"$branch"
        echo
      fi
    fi
  done
}

function return_to_starting_branch {
  if [[ $v_start_branch != "$v_dev_branch" && $(git cat-file -t "$v_start_branch" 2> /dev/null) ]]; then
    # The output is very noisy for non-named branches.
    git checkout - 2>&1 | head -n 1
    echo
  fi
}

# MAIN ###########################################

decode_cmdline_params "$@"
check_working_tree
store_branch_names
set_protected_branches
sync_repositories
switch_to_dev_branch
rebase_dev_branch
delete_empty_branches
return_to_starting_branch
