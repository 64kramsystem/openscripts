#!/bin/bash

set -o errexit
set -o nounset

# shellcheck disable=SC2016
help="Usage: $(basename "$0") [-d|--destination <dir>] [-t|--process-in-tmpdir] [-q|--quality <quality>] [-r|--remove] <input1> {<inputN>, ...}

Encodes to m4a and applies gain.

The "'`input`'" values can be either files or directories:

- if they're files: track gain is applied (individually)
- if they're directories:
  - album gain is applied, on a directory basis, to lossless files
  - non-audio files are ignored
  - subdirectories are not descended

If \`process-in-tmpdir\` is set, files are processed in a temporary directory, instead of in-place. This helps on destinations like (GVFS) mounts on mobile devices, where file operations other than basic copy/move may fail.

Compressed input audio files which are not flac are copied, without being reencoded.

The codec used is libfdk_aac, in VBR, with a default quality of 3 (~110 kbps).

Requires aacgain and a recompiled FFmpeg.

Please note that not all the input/quality combinations work (see https://hydrogenaud.io/index.php/topic,95989.msg817833.html#msg817833).
"

eval set -- "$(getopt --options hd:tq:ar --long help,destination:,process-in-tmpdir,quality:,album,remove -- "$@")"

destination="."
quality="3"
remove_file=
process_in_tmpdir=

while true ; do
  case "$1" in
    -h|--help)
      echo "$help"
      exit 0 ;;
    -d|--destination)
      destination="$2"
      shift 2 ;;
    -t|--process-in-tmpdir)
      process_in_tmpdir=1
      shift ;;
    -q|--quality)
      quality="$2"
      shift 2 ;;
    -r|--remove)
      remove_file=1
      shift ;;
    --)
      shift
      break ;;
  esac
done

if [[ $# -eq 0 ]]; then
  echo "$help"
  exit 1
fi

# If `process_in_tmpdir` is set, then the name of a temporary file with the same extension as `$1`
# is printed; otherwise, `$1` is printed.
#
function create_intermediate_file_name {
  if [[ $process_in_tmpdir == 1 ]]; then
    echo "$(mktemp --suffix=".${1##*.}")"
  else
    echo "$1"
  fi
}

function encode_file {
  file_mime_type="$(file --mime-type "$1" | grep -oP '\S+/\S+$')"

  case "$file_mime_type" in
  audio/x-flac | audio/x-wav )
    echo "Encoding $1..."

    destination_file="$destination/$(basename "${1%.*}.m4a")"
    intermediate_file="$(create_intermediate_file_name "$destination_file")"

    ffmpeg -y -hide_banner -loglevel panic -i "$1" -vn -c:a libfdk_aac -vbr "$quality" "$intermediate_file"
    ;;
  audio/x-m4a | video/mp4 | audio/mpeg )
    echo "Copying $1..."

    destination_file="$destination/$(basename "$1")"
    intermediate_file="$(create_intermediate_file_name "$destination_file")"

    cp "$1" "$intermediate_file"
    ;;
  * )
    echo "Unsupported file type for file source \"$1\": $file_mime_type"
    exit 1
    ;;
  esac

  echo -n "Normalizing (track) "

  # `-s -r`: ignore ffmpeg written tags, which set the album gain for each track separately.
  #
  aacgain -q -k -r -s r "$intermediate_file"

  [[ $process_in_tmpdir == 1 ]] && mv "$intermediate_file" "$destination_file" || true

  [[ $remove_file == 1 ]] && rm -f "$source_file" || true
}

function encode_directory {
  destination_subdir="$destination/$(basename "$1")"

  if [[ $process_in_tmpdir == 1 ]]; then
    intermediate_subdir="$(mktemp -d)"
  else
    intermediate_subdir="$destination_subdir"
    mkdir -p "$intermediate_subdir"
  fi

  for source_subfile in "$1"/*; do
    file_mime_type="$(file --mime-type "$source_subfile" | grep -oP '\S+/\S+$')"

    case "$file_mime_type" in
    audio/x-flac | audio/x-wav )
      echo "Encoding $source_subfile..."

      destination_subfile="$intermediate_subdir/$(basename "${source_subfile%.*}.m4a")"

      ffmpeg -y -hide_banner -loglevel panic -i "$source_subfile" -vn -c:a libfdk_aac -vbr "$quality" "$destination_subfile"
      ;;
    audio/x-m4a | video/mp4 | audio/mpeg )
      echo "Copying $source_subfile..."

      destination_subfile="$intermediate_subdir/$(basename "$source_subfile")"

      cp "$source_subfile" "$destination_subfile"
      ;;
    audio/* )
      echo "Unsupported file type for file source \"$source_subfile\": $file_mime_type"
      exit 1
      ;;
    image/* )
      echo "Copying $source_subfile..."

      cp "$source_subfile" "$intermediate_subdir/"
      ;;
    * )
      ;; # ignore other cases (eg. text files)
    esac
  done

  echo "Normalizing (album) $destination_subdir (tmp dir: $intermediate_subdir)..."

  # See `-s -r` note in the previous invocation.
  #
  # We can use the wildcard because aacgain ignores non-audio files (prints the names while
  # scanning, but doesn't process them).
  #
  aacgain -q -k -a -s r "$intermediate_subdir"/*

  [[ $process_in_tmpdir == 1 ]] && mv "$intermediate_subdir" "$destination_subdir" || true

  [[ $remove_file == 1 ]] && rm -r "$1" || true
}

for source_file in "$@"; do
  if [[ -f "$source_file" ]]; then
    encode_file "$source_file"
  elif [[ -d "$source_file" ]]; then
    encode_directory "$source_file"
  else
    echo "Source type not recognized: $source_file"
    exit 1
  fi
done
