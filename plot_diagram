#!/usr/bin/env ruby

require 'simple_scripting/argv'
require 'csv'
require 'tempfile'
require 'tmpdir'

class PlotDiagramCommandLineDecoder
  def decode_cmline_args
    long_help = <<~HELP
      Plots a diagram (with a single Y scale) from a file (or stdin, when the file is not specified).

      Multiple formats are accepted.

      - the data can have a single column; in this case, it won't have X values:

          4
          7
          6

      - when there are two or more columns, the first column represents the X values:

          1 4 2
          2 7 3
          3 6 2

      - if one wants multiple lines without X values, specify `--no-x`:

          4 2
          7 3
          6 2

      The default fields separator is space; in order to specify comma separated fields (CSV-alike), use the `--csv` option.

      If `--output` is specified, the format is automatically gathered from the extension (currently, #{PlotDiagram::IMAGE_FORMATS_MAPPING.keys.join('/')} are supported.)

      Common date (not time) formats are automatically recognized for the x column, eg.:

          2015-May-08 1 3
          2015-May-09 1 4

    HELP

    SimpleScripting::Argv.decode(
      ['-c', '--csv',                     'Sets the input format as CSV'],
      ['-s', '--smooth',                  'Smooth line'],
      ['-x', '--no-x',                    'With multiple columns, build a diagram without X values'],
      ['-t', '--titles TITLE_1,TITLE_N',  'Set the titles'],
      ['-o', '--output FILENAME',         'Outputs to the specified file, instead of printing to screen'],
      ['-v', '--verbose',                 'Verbose mode (prints gnuplot commands)'],
      '[data_file]',
    ) || exit
  end
end

class PlotDiagram
  DEFAULT_Y_TITLE_PREFIX = 'y'
  DIAGRAM_SIZE = [1600, 900]
  IMAGE_FORMATS_MAPPING = {
    'png' => 'pngcairo',
    'svg' => "svg enhanced background rgb 'white'", # transparent is ugly on some platforms
  }
  MONTHS = %w[jan feb mar apr may jun jul aug sep oct nov dec]
  Y_PADDING_FRACTION = 0.04 # fraction of range

  # options:
  #   :csv
  #   :smooth
  #   :no_x
  #   :titles
  #   :output
  #   :verbose
  #
  def plot(data_file, options={})
    # When the data is passed from stdin, we need to store it, because the script reads the data
    # twice.
    #
    data_file, data_file_is_temporary = prepare_data_file(data_file)

    gnuplot_commands = prepare_gnuplot_commands(data_file, options)

    execute_gnuplot_commands(gnuplot_commands, options)
  rescue => error
    puts error
    exit 1
  ensure
    File.unlink(data_file) if data_file_is_temporary && File.exists?(data_file)
  end

  private

  def prepare_data_file(data_file)
    if data_file.nil?
      data_file = Dir::Tmpname.create(['plot_data', '.txt']) { }
      IO.write(data_file, $stdin.read)

      [data_file, true]
    else
      [data_file, false]
    end
  end

  def prepare_gnuplot_commands(data_file, csv: false, no_x: false, smooth: false, titles: nil, output: nil, **)
    data = parse_data_file(data_file, csv)
    x_time_format = find_x_time_format(data)
    using_prefix, start_index = compute_using_settings(x_time_format, no_x)
    data_column_numbers = find_data_columns_number(data)
    titles = check_and_prepare_titles(titles, data_column_numbers, start_index)

    commands = prepare_command_output_settings(output)
    commands += prepare_command_graph_offset
    commands += prepare_command_csv_setting if csv
    commands += prepare_command_date_settings(no_x, x_time_format) if x_time_format
    commands += prepare_command_plot_keyword
    commands += prepare_command_plot_lines(smooth, data_column_numbers, data_file, using_prefix, titles, start_index)
    commands + prepare_commands_pause
  end

  def execute_gnuplot_commands(commands, verbose: false, **)
    puts "# Running command:", "", commands, "" if verbose

    Tempfile.create(['plot_diagram', '.gp']) do |file|
      file.puts(commands)
      file.close

      # Madness. There is no clean way of waiting for the diagram window to be close before exiting
      # gnuplot (--persist leaves the diagram window open, but gnuplots exits).
      # `pause mouse close` does achieve this effect, but requires return to be tapped, after the
      # window is closed.
      # Therefore, we use `pause mouse close`, but we send a newline to stdin (!!!).
      #
      `echo | gnuplot --persist #{file.path}`
    end
  end

  ######################################################################################
  # COMMANDS CREATION
  ######################################################################################

  def prepare_command_output_settings(output)
    if output
      output_extension = output[/\w+$/]
      terminal_format = IMAGE_FORMATS_MAPPING[output_extension] || raise("File extension not supported: #{output_extension.inspect}")

      <<~PLOT
        set terminal #{terminal_format} size #{DIAGRAM_SIZE.join(',')}
        set output '#{output}'
      PLOT
    else
      "set terminal wxt size #{DIAGRAM_SIZE.join(',')}\n"
    end
  end

  def prepare_command_graph_offset
    "set offset graph 0, 0, #{Y_PADDING_FRACTION}, #{Y_PADDING_FRACTION}\n"
  end

  def prepare_command_csv_setting
    "set datafile separator ','\n"
  end

  def prepare_command_date_settings(no_x, x_time_format)
    raise "Date format detected on the first column, but `--no-x` has been specified!" if no_x

    commands += <<~PLOT
      set xdata time
      set timefmt '#{x_time_format}'
    PLOT
  end

  def prepare_command_plot_keyword
    "plot \\\n"
  end

  def prepare_command_plot_lines(smooth, data_column_numbers, data_file, using_prefix, titles, start_index)
    smooth_option = "smooth sbezier" if smooth

    start_index.upto(data_column_numbers).inject("") do |commands, i|
      commands += " '#{data_file}' using #{using_prefix}#{i} with linespoints #{smooth_option} title '#{titles[i - start_index]}'"
      commands += ', \\' if i < data_column_numbers
      commands + "\n"
    end
  end

  # See comment in execute_gnuplot_commands.
  #
  def prepare_commands_pause
    "pause mouse close\n"
  end

  ######################################################################################
  # HELPERS
  ######################################################################################

  def parse_data_file(data_file, csv)
    if csv
      data = CSV.read(data_file)
    else
      data = IO.readlines(data_file).map { |line| line.strip.split(/\s+/) }
    end

    if data.empty?
      raise "No data found in the file!"
    end

    data
  end

  def find_x_time_format(data)
    first_potential_timestamp = data[0][0][/^[\w-]+/]

    case first_potential_timestamp
    when /^\d{,2}-\d{,2}$/
      "%m-%d"
    when /^(#{MONTHS.join'|'})-\d{,2}$/i
      "%b-%d"
    when /^\d{4}-\d{,2}-\d{,2}$/
      "%Y-%m-%d"
    when /^\d{2}-\d{,2}-\d{,2}$/
      "%y-%m-%d"
    when /^\d{4}-(#{MONTHS.join'|'})-\d{,2}$/i
      "%Y-%b-%d"
    when /^\d{2}-\d{,2}-\d{,2}$/
      "%y-%b-%d"
    else
      nil
    end
  end

  # Returns [using_prefix, start_index]
  def compute_using_settings(x_time_format, no_x)
    if x_time_format || !no_x
      # Required when specifying time data.
      ["1:", 2]
    else
      [nil, 1]
    end
  end

  def find_data_columns_number(data)
    data.first.size
  end

  def check_and_prepare_titles(titles, data_column_numbers, start_index)
    if titles
      y_columns_number = data_column_numbers + 1 - start_index

      if titles.size != y_columns_number
        raise "Mismatching number of titles/Y columns: #{titles.size}/#{y_columns_number}"
      end
    else
      titles = start_index.upto(data_column_numbers).map { |i| "#{DEFAULT_Y_TITLE_PREFIX}#{i}" }
    end

    titles.map { |title| title.gsub('_', '\_') }
  end
end

if __FILE__ == $PROGRAM_NAME
  options = PlotDiagramCommandLineDecoder.new.decode_cmline_args

  data_file = options.delete(:data_file)

  PlotDiagram.new.plot(data_file, options)
end
