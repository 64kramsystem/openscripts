#!/usr/bin/env bash

set -o pipefail
set -o errexit
set -o nounset
set -o errtrace
shopt -s inherit_errexit

c_bisect_local_version=bisect
c_cherry_picks_log=$(dirname "$(mktemp -d)")/build_kernel.cherry-picks.log
# Example: https://kernel.ubuntu.com/mainline/v6.7/
c_mainline_ppa_url=https://kernel.ubuntu.com/mainline/
# Example: https://kernel.ubuntu.com/mainline/v6.8-rc1/amd64/linux-modules-6.8.0-060800rc1-generic_6.8.0-060800rc1.202401212233_amd64.deb
c_package_name_pattern="amd64/linux-modules-[[:alnum:]_.-]+_amd64+\.deb"
c_help="Usage: $(basename "$0") [-h|--help] <options...> [packages_destination]

Builds a kernel from the source code.

The list (newline-separated) of built packages is sent to FD 3 (if open/valid).

Options:

- [-v|--kernel-version <version>]
- [-b|--bisect]                   : bisect mode (see below); incompatible with '--kernel-version'
- [-l|--local-version <name>]     : set the kernel local version (name suffix), defaults to \$BUILD_KERNEL_LOCAL_VERSION; the
                                    minus is automatically added
- [-c|--cherry-pick <c1,c2,...>]  : cherry pick commits, defaults to \$BUILD_KERNEL_CHERRY_PICKS; see help below for the format
- [-i|--install]
- [-r|--repo-path <path>]         : defaults to (current path or \$BUILD_KERNEL_REPO_PATH env variable)
- [-d|--display-config-diff]

Parameters:

- packages_destination : mandatory; can be specified via \$BUILD_KERNEL_PACKAGES_DESTINATION

Options/parameters override the corresponding env variables.

Workflow (regular):

- fetches the remote(s) and finds the latest patch version, for the running or specified kernel
- checks the target version's branch out
- find the target version's config, and copies it to the packages destination
- patches the configuration to make it compile (assumes it's Ubuntu), and updates it
- removes the old packages/configs from the packages destination
- builds and moves the packages to the packages destination
- if --install is specified, it installs the packages

Workflow (bisect):

- the kernel local version is set to '$c_bisect_local_version', overriding any user setting
- the kernel version is gathered from the latest tag reachable from HEAD
- (the configuration is handled as regular)
- removes the old packages (not the configs) from the packages destination
- builds and moves the packages to the packages destination
- installs the packages

Cherry picking:

- the format is 'shortver1:c1a,c1b;shortver2:c2a,c2b'
- 'shortver' is optional, and defaults to the current kernel short version
- each commit can be prefixed with 'R', which will revert the given commit
"

v_kernel_version=
v_bisect=               # boolean; false=blank; true=anything else
v_install=              # boolean; false=blank; true=anything else
v_packages_destination=${BUILD_KERNEL_PACKAGES_DESTINATION:-}
v_repo_path=${BUILD_KERNEL_REPO_PATH:-}
v_local_version=${BUILD_KERNEL_LOCAL_VERSION:-}
v_display_config_diff=  # boolean; false=blank; true=anything else
v_raw_cherry_picks=${BUILD_KERNEL_CHERRY_PICKS:-} # see help for the format

function decode_cmdline_args {
  local params
  params=$(getopt --options hv:bir:l:dc: --long help,kernel-version:,bisect,install,repo-path:,local-version:,display-config-diff,cherry-pick: --name "$(basename "$0")" -- "$@")

  eval set -- "$params"

  while true; do
    case $1 in
      -h|--help)
        echo "$c_help"
        exit 0 ;;
      -v|--kernel-version)
        v_kernel_version=$2
        shift 2 ;;
      -b|--bisect)
        v_bisect=1
        shift ;;
      -i|--install)
        v_install=1
        shift ;;
      -r|--repo-path)
        v_repo_path=$2
        shift 2 ;;
      -l|--local-version)
        v_local_version=$2
        shift 2 ;;
      -d|--display-config-diff)
        v_display_config_diff=1
        shift ;;
      -c|cherry-pick)
        v_raw_cherry_picks=$2
        shift 2 ;;
      --)
        shift
        break ;;
    esac
  done

  if [[ $# -gt 1 ]]; then
    echo "Only one argument is allowed!"
    exit 1
  elif [[ -n $v_bisect && -n $v_kernel_version ]]; then
    echo "Bisection and specific kernel version are incompatible!"
    exit 1
  elif [[ $# -eq 1 ]]; then
    v_packages_destination=$1
  else
    if [[ -z $v_packages_destination ]]; then
      >&2 echo "Missing packages destination!"
      exit 1
    fi
  fi

  if [[ ! -d $v_packages_destination ]]; then
    >&2 echo "Invalid packages destination!"
    exit 1
  fi

  if [[ -n $v_bisect ]]; then
    v_local_version=$c_bisect_local_version
    v_install=1
  fi
}

function cache_sudo {
  sudo -v

  while true; do
    sleep 60
    kill -0 "$$" || exit
    sudo -nv
  done 2>/dev/null &
}

# Return format: `M.m.p` or `M.m.0-rcN`
#
function find_running_kernel_version {
  uname -r | sed -E 's/-[^-]+$//'
}

# Return format: `M.m.p` or `M.m-rcN`.
#
function normalize_kernel_version {
  local version=$1

  if [[ $version =~ ^[[:digit:]]+\.[[:digit:]]+$ ]]; then
    echo -n "$version.0"
  else
    echo -n "$version"
  fi
}

# Shorten the kernel version:
#
# - `with_rc`: remove the patch `0` version (present in GA versions), but keep the RC (if present)
# - `no_rc`  : remove both the patch `0` and RC versions
#
# $2: `with_rc` or `no_rc`
#
function short_kernel_version {
  case $2 in
  with_rc)
    echo "$1" | perl -pe 's/^\d+\.\d+\K\.0//'
    ;;
  no_rc)
    echo "$1" | perl -ne 'print /^(\d+\.\d+)/'
    ;;
  *)
    >&2 echo "Invalid short version mode: $2"
    exit 1
    ;;
  esac
}

function fetch_remotes {
  git fetch --all
}

# Return format: `M.m.p` or `M.m-rcN`.
#
function find_latest_kernel_version {
  local normalized_version=$1

  local short_version
  short_version=$(short_kernel_version "$normalized_version" no_rc)
  local escaped_short_version=${short_version//./\\.}

  # Append a zero to GA releases, otherwise, `sort -V` places it before the RCs.
  #
  local latest_version
  latest_version=$(
    git tag \
      | grep -P "^v$escaped_short_version"'($|-rc|\.)' \
      | perl -pe 's/^v\d+\.\d+\K$/.0/' \
      | sort -V \
      | tail -n 1 \
      | perl -pe 's/^v//' \
    || true
  )

  if [[ -z $latest_version ]]; then
    >&2 echo "No kernel versions found for v$short_version."
    exit 1
  fi

  echo -n "$latest_version"
}

# Return format: `M.m.p` or `M.m-rcN`.
#
function find_branch_kernel_version {
  git describe --tags --abbrev=0 \
    | perl -pe 's/^v\d+\.\d+\K$/.0/' \
    | perl -pe 's/^v//'
}

# See remove_destination_old_version_files() for the filenames format.
#
# Returns the config file full path.
#
function find_config_file_for_version {
  local kernel_version=$1

  find "$v_packages_destination" -name "config-$kernel_version" -printf "%p"
}

# Find the link of the module package corresponding to the latest PPA config available for the (short)
# version of the given kernel.
#
function find_latest_ppa_config_module_link {
  local target_version
  target_version=$(short_kernel_version "$1" no_rc)

  local builds_url=${c_mainline_ppa_url}v$target_version

  declare -x target_version_regex=${target_version//./\\.}

  local mainline_ppa_page_content
  mainline_ppa_page_content=$(wget --quiet "$builds_url" --output-document -)

  # Examples:
  #
  #   >v6.6/</a>
  #   >v6.7-rc1/</a>
  #   >v6.7.1/</a>
  #
  # Append a zero to GA releases, otherwise, `sort -V` places it before the RCs.
  #
  local candidate_versions
  mapfile -t candidate_versions < <(
    echo "$mainline_ppa_page_content" \
    | perl -lne 'print $1 if />v($ENV{target_version_regex}(\.\d+|-rc\d+)?)\/</' \
    | perl -pe 's/^\d+\.\d+\K$/.0/' \
    | sort --version-sort --reverse
  )

  for candidate_version in "${candidate_versions[@]}"; do
    local amd64_modules_package_link
    amd64_modules_package_link=$(find_amd64_modules_package_link "$candidate_version")

    if [[ -n $amd64_modules_package_link ]]; then
      echo -n "$amd64_modules_package_link"
      return
    fi
  done

  >&2 echo "No config (module package) found for version $target_version"
  exit 1
}

function check_if_version_already_packaged {
  local current_kernel_version=$1 building_kernel_version=$2

  # Format: `M.m.p` or or `M.m-rcN`.
  #
  local latest_packaged_version
  latest_packaged_version=$(find_latest_packaged_version "$building_kernel_version")

  if [[ $building_kernel_version == "$latest_packaged_version" ]]; then
    echo "No new version! Latest packaged/available: $building_kernel_version"
    exit 0
  fi
}

# Assumes that there are no multiple builds for the same version.
#
# Return format: `M.m.p` or `M.m-rcN`.
#
function find_latest_packaged_version {
  local kernel_version=$1

  if [[ $kernel_version =~ ^([0-9]+\.[0-9]+)($|-rc) ]]; then
    kernel_version=${BASH_REMATCH[1]}.0
  fi

  # Use the image package for reference.
  #
  # See remove_destination_old_version_files() for the filenames format.
  #
  find "$v_packages_destination" -printf "%P\n" |
    perl -ne 'print $1 if /^linux-image-('"$kernel_version"'(-rc\d+)?)/' |
    sort -V |
    tail -n 1 |
    perl -pe 's/\.0(?=-rc)//' ||
    true
}

function find_amd64_modules_package_link {
  local kernel_version=$1

  local package_kernel_version
  package_kernel_version=$(short_kernel_version "$kernel_version" with_rc)

  local builds_url=${c_mainline_ppa_url}v$package_kernel_version

  local builds_page_content
  builds_page_content=$(wget --quiet "$builds_url" --output-document - || true)

  if [[ -n $builds_page_content ]]; then
    [[ $builds_page_content =~ $c_package_name_pattern ]] || true

    if [[ -n "${BASH_REMATCH[*]}" ]]; then
      echo -n "$builds_url/${BASH_REMATCH[0]}"
    fi
  fi
}

# Prints the full path of the extracted config file, transformed to use the standard naming.
#
function download_and_extract_config_file_from_modules_package {
  local amd64_modules_package_link=$1

  local local_package_name=
  local_package_name=$(dirname "$(mktemp --dry-run)")/${amd64_modules_package_link##*/}

  wget "$amd64_modules_package_link" --output-document "$local_package_name"

  # Examples:
  #
  #   ./boot/config-6.7.0-060700-generic
  #   ./boot/config-6.10.0-061000rc1-generic
  #
  # The filename returned is the input one, so we need to further process it.
  #
  local raw_config_file
  raw_config_file=$(
    dpkg-deb --fsys-tarfile "$local_package_name" \
      | tar xv -C "$v_packages_destination" --wildcards --transform="s|^\./boot/||" "./boot/config-*" \
      | perl -pe 's|^\./boot/||'
  )

  # We can't unify the regex easily, because of the required dash preceding the `rc` in the desired
  # output.
  #
  if [[ $raw_config_file == *rc* ]]; then
    config_file=$(echo "$raw_config_file" | perl -pe 's/\.0-\d{6}(rc\d+)-generic/-$1/')
  else
    config_file=$(echo "$raw_config_file" | perl -pe 's/(\.0)?-\d{6}-generic//')
  fi

  # Make sure that the processing was correct.
  #
  if [[ -z $(echo "$config_file" | perl -ne 'print if /^config-\d+\.\d+(\.\d+|-rc\d+)?$/') ]]; then
    >&2 "Config filename processing failed: $raw_config_file"
    exit 1
  fi

  mv "$v_packages_destination/$raw_config_file" "$v_packages_destination/$config_file"

  echo -n "$v_packages_destination/$config_file"
}

# `M.m.0` versions are stored without the patch version.
#
function create_if_required_and_switch_branch {
  local building_kernel_version=$1

  if [[ $building_kernel_version =~ \.0$ ]]; then
    building_kernel_version=${building_kernel_version%.0}
  fi

  local branch_working_copy=bv"$building_kernel_version"

  # When switching across branches for different non-patch versions, some files may be end up changed,
  # which blocks the checkout; in order to solve this, we do `--force`d checkout.
  #
  if git rev-parse --verify "$branch_working_copy" 2> /dev/null; then
    git checkout --force "$branch_working_copy"
  else
    git checkout -b "$branch_working_copy" --force v"$building_kernel_version"
  fi
}

function same_major_minor_version {
  local short_version_1 short_version_2

  short_version_1=$(short_kernel_version "$1" no_rc)
  short_version_2=$(short_kernel_version "$2" no_rc)

  [[ $short_version_1 == "$short_version_2" ]]
}

function print_sorted_commits_diff {
  local previous_version=$1

  previous_version=$(short_kernel_version "$previous_version" with_rc)

  git cherry -v "v$previous_version" | sort -k3
}

function import_config_file {
  cp "$source_config_file" .config
}

function make_ubuntu_config_build {
  scripts/config --set-str SYSTEM_TRUSTED_KEYS ""
  scripts/config --set-str SYSTEM_REVOCATION_KEYS ""
}

function apply_secondary_config_patches {
  # Disable debug info (pretty chunky!).
  #
  scripts/config --undefine DEBUG_INFO
  scripts/config --undefine DEBUG_INFO_COMPRESSED
  scripts/config --undefine DEBUG_INFO_REDUCED
  scripts/config --undefine DEBUG_INFO_SPLIT
  scripts/config --undefine GDB_SCRIPTS
  scripts/config --set-val DEBUG_INFO_DWARF5 n
  scripts/config --set-val DEBUG_INFO_NONE y

  # Some don't make any measurable comptime improvements, but anyway they're not used
  #
  # On my current setup, compilation without (deb's or changes below) takes ~479".
  # With the changes below takes ~455".
  #
  # To test:
  #
  #     make mrproper
  #     cp .config{.sav,}
  #     # (apply below)
  #     make olddefconfig
  #     /usr/bin/time -f "TIME: %e" make -j $(nproc)
  #     plin
  #
  scripts/config --disable  CONFIG_CPU_SUP_HYGON            # exotic hw architectures...
  scripts/config --disable  CONFIG_CPU_SUP_CENTAUR
  scripts/config --disable  CONFIG_CPU_SUP_ZHAOXIN
  scripts/config --disable  CONFIG_DRM_RADEON               # radeon...
  scripts/config --undefine CONFIG_DRM_RADEON_USERPTR
  scripts/config --disable  CONFIG_DRM_NOUVEAU              # nouveau...
  scripts/config --undefine CONFIG_NOUVEAU_DEBUG
  scripts/config --undefine CONFIG_NOUVEAU_DEBUG_DEFAULT
  scripts/config --undefine CONFIG_NOUVEAU_DEBUG_MMU
  scripts/config --undefine CONFIG_NOUVEAU_DEBUG_PUSH
  scripts/config --undefine CONFIG_DRM_NOUVEAU_BACKLIGHT
  scripts/config --undefine CONFIG_DRM_NOUVEAU_SVM
  scripts/config --undefine CONFIG_DRM_NOUVEAU_GSP_DEFAULT
  scripts/config --disable  CONFIG_DRM_XE                   # intel xe...
  scripts/config --undefine CONFIG_DRM_GPUVM
  scripts/config --undefine CONFIG_DRM_XE_DISPLAY
  scripts/config --undefine CONFIG_DRM_XE_FORCE_PROBE
  scripts/config --undefine CONFIG_DRM_XE_WERROR
  scripts/config --undefine CONFIG_DRM_XE_DEBUG
  scripts/config --undefine CONFIG_DRM_XE_DEBUG_VM
  scripts/config --undefine CONFIG_DRM_XE_DEBUG_SRIOV
  scripts/config --undefine CONFIG_DRM_XE_DEBUG_MEM
  scripts/config --undefine CONFIG_DRM_XE_LARGE_GUC_BUFFER
  scripts/config --undefine CONFIG_DRM_XE_USERPTR_INVAL_INJECT
  scripts/config --undefine CONFIG_DRM_XE_JOB_TIMEOUT_MAX
  scripts/config --undefine CONFIG_DRM_XE_JOB_TIMEOUT_MIN
  scripts/config --undefine CONFIG_DRM_XE_TIMESLICE_MAX
  scripts/config --undefine CONFIG_DRM_XE_TIMESLICE_MIN
  scripts/config --undefine CONFIG_DRM_XE_PREEMPT_TIMEOUT
  scripts/config --undefine CONFIG_DRM_XE_PREEMPT_TIMEOUT_MAX
  scripts/config --undefine CONFIG_DRM_XE_PREEMPT_TIMEOUT_MIN
  scripts/config --undefine CONFIG_DRM_XE_ENABLE_SCHEDTIMEOUT_LIMIT
  scripts/config --disable  CONFIG_DRM_MGAG200              # matrox g200
}

function set_new_config_defaults {
  make olddefconfig
}

function display_config_diff {
  # Assume that the error status 2 (real error) can't happen, because the file exists.
  #
  if ! diff .config{.bak,} > /dev/null; then
    meld .config{.bak,}
  fi
}

# $1: current kernel version
#
# $v_raw_cherry_picks can be empty, in which case no CPs are performed.
#
function cherry_pick_commits {
  local short_current_kernel_version
  short_current_kernel_version=$(short_kernel_version "$1" no_rc)

  local raw_cherry_pick_entries
  mapfile -d';' raw_cherry_pick_entries < <(echo -n "$v_raw_cherry_picks")

  # Don't bother with an exit deletion hook.
  #
  true > "$c_cherry_picks_log"

  for cherry_picks_entry in "${raw_cherry_pick_entries[@]}"; do
    if [[ $cherry_picks_entry != *:* ]]; then
      cherry_picks_entry=$short_current_kernel_version:$cherry_picks_entry
    fi

    local entry_kernel_version=${cherry_picks_entry%:*}

    if [[ $entry_kernel_version == "$short_current_kernel_version" ]]; then
      local entry_raw_commits=${cherry_picks_entry#*:}

      local entry_commits
      mapfile -td, entry_commits < <(echo -n "$entry_raw_commits")

      for commit in "${entry_commits[@]}"; do
        local operation_error_log
        operation_error_log=$(mktemp)

        local header="# CHERRY PICK $commit ##################################################"
        echo "$header"

        if [[ $commit == R* ]]; then
          # Git revert is inconsistent: when a revert has already been applied, it exits with error,
          # but outputs to stdout; for this reason, we need to capture both stdout and stderr;
          # additionally, it will cause git revert --abort to fail (which in turn, outputs to
          # stderr instead). ðŸ¤·
          #
          if ! git revert --no-edit "${commit#R}" > "$operation_error_log" 2>&1; then
            git revert --abort 2> /dev/null || true
            { echo "$header"; cat "$operation_error_log"; } >> "$c_cherry_picks_log"
          fi
        else
          if ! git cherry-pick "$commit" 2> "$operation_error_log"; then
            git cherry-pick --abort
            { echo "$header"; cat "$operation_error_log"; } >> "$c_cherry_picks_log"
          fi
        fi

        rm "$operation_error_log"
      done
    fi
  done
}

function compile_kernel {
  local make_options=()

  if [[ -n $v_local_version ]]; then
    make_options+=(LOCALVERSION=-"$v_local_version")
  fi

  make -j "$(nproc)" bindeb-pkg "${make_options[@]}"
}

function remove_destination_old_version_files {
  local raw_version=$1 source_config_file=$2

  local short_version
  short_version=$(short_kernel_version "$raw_version" no_rc)

  # This is actually redundant, although by using the basename, we make this logic more robust.
  #
  local source_config_file
  source_config_file=$(basename "$source_config_file")

  # Note that at least one configuration is necessarily present, but not the packages.

  if [[ -z $v_bisect ]]; then
    # Sample filenames:
    #
    # - config-6.9.0
    # - config-6.10-rc2
    #
    # Ignore configurations that don't follow the convention, so that they can be used for other purposes,
    # e.g. reference/backup.
    #
    find "$v_packages_destination" -regextype egrep -not -name "$source_config_file" -regex ".*/config-$short_version(\.|-rc)[[:digit:]]+" -exec rm {} \;
  fi

  # Sample filenames:
  #
  # - linux-headers-6.1.9-mybuild_6.1.9-mybuild-4_amd64.deb
  # - linux-image-6.1.9-mybuild_6.1.9-mybuild-4_amd64.deb
  # - linux-libc-dev_6.1.9-mybuild-4_amd64.deb
  #
  # - linux-headers-6.10.0-rc2-mybuild_6.10.0-rc2-65_amd64.deb
  #
  find "$v_packages_destination" -regextype egrep -regex ".*/.+[-_]$short_version\..+\.deb" -exec rm {} \;
}

function move_packages_and_cleanup {
  mv ../*.deb "$v_packages_destination"/
  rm ../*.{changes,buildinfo}
}

# Output the package filenames, newline-separated.
#
function find_built_packages {
  local normalized_version=$1

  local short_version
  short_version=$(short_kernel_version "$normalized_version" no_rc)

  # See remove_destination_old_version_files() for the filenames format.
  #
  find "$v_packages_destination" -name "linux-*[-_]$short_version.*-*.deb"
}

# Doesn't uninstall the libc package (which doesn't carry the local version), but we can live with it.
#
function remove_installed_bisect_kernels {
  sudo aptitude purge -y ~i"linux-.*-$c_bisect_local_version"
}

# $1: see find_built_packages().
#
function install_kernel_packages {
  local packages_to_install
  mapfile -t packages_to_install < <(echo -n "$1")

  sudo dpkg -i "${packages_to_install[@]}"
}

# Sends only if the FD is open/valid.
#
# $1: see find_built_packages().
#
function send_built_packages_to_fd3 {
  if { true >&3; } 2>/dev/null; then
    echo -n "$1" >&3
  fi
}

function main {
  if [[ -n $v_install ]]; then
    cache_sudo
  fi

  if [[ -n $v_repo_path ]]; then
    cd "$v_repo_path"
  fi

  # The tag (and mainline PPA path) for `M.m.0` versions is in the `M.m` format.
  # We need to normalize regardless, because the version can also be passed by the user.

  local current_kernel_version=${v_kernel_version:-"$(find_running_kernel_version)"}
  current_kernel_version=$(normalize_kernel_version "$current_kernel_version")

  if [[ -z $v_bisect ]]; then
    fetch_remotes
  fi

  local building_kernel_version

  if [[ -z $v_bisect ]]; then
    building_kernel_version=$(find_latest_kernel_version "$current_kernel_version")

    check_if_version_already_packaged "$current_kernel_version" "$building_kernel_version"

    create_if_required_and_switch_branch "$building_kernel_version"

    # When specifying a different kernel version, don't display the diff.
    #
    if [[ -z $v_kernel_version ]] && same_major_minor_version "$current_kernel_version" "$building_kernel_version"; then
      print_sorted_commits_diff "$current_kernel_version"
    fi
  else
    building_kernel_version=$(find_branch_kernel_version)
  fi

  local source_config_file
  source_config_file=$(find_config_file_for_version "$building_kernel_version")

  # If the matching version is not found locally, search it on the mainline PPA.
  #
  if [[ -z $source_config_file ]]; then
    # Package operations condensed for readability purposes.

    local amd64_modules_package_link
    amd64_modules_package_link=$(find_amd64_modules_package_link "$building_kernel_version")

    if [[ -z $amd64_modules_package_link ]]; then
      # If the matching version is not found on the PPA, search the latest config for the given short version.
      # We could search from the precise version backwards, but it's not worth.

      local amd64_modules_package_link
      amd64_modules_package_link=$(find_latest_ppa_config_module_link "$building_kernel_version")
    fi

    source_config_file=$(download_and_extract_config_file_from_modules_package "$amd64_modules_package_link")
  fi

  import_config_file "$source_config_file"

  # Always patch for simplicity, so if we want to replace the config for a version with an existing
  # configuration, we don't need to manually patch it.

  make_ubuntu_config_build
  apply_secondary_config_patches
  set_new_config_defaults

  if [[ -n $v_display_config_diff ]]; then
    display_config_diff
  fi

  cherry_pick_commits "$current_kernel_version"

  compile_kernel

  # Config files are handled based on $v_bisect.
  #
  remove_destination_old_version_files "$current_kernel_version" "$source_config_file"

  move_packages_and_cleanup

  local built_packages
  built_packages=$(find_built_packages "$building_kernel_version")

  if [[ -n $v_install ]]; then
    if [[ -n $v_bisect ]]; then
      remove_installed_bisect_kernels
    fi
    install_kernel_packages "$built_packages"
  fi

  if [[ -s $c_cherry_picks_log ]]; then
    {
      echo "Cherry picking failures:"
      cat "$c_cherry_picks_log"
    } >&2
  fi

  send_built_packages_to_fd3 "$built_packages"
}

decode_cmdline_args "$@"
main
